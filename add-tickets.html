<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add Tickets - Crowd</title>
    <link rel="stylesheet" href="add-tickets-styles.css">
    <style>
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .error-notification, .notification {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="tickets-container">
        <!-- Left Sidebar -->
        <aside class="left-sidebar">
            <div class="sidebar-content">
                <div class="back-link">
                    <a href="event-builder.html">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M15 18l-6-6 6-6"/>
                        </svg>
                        Back to event details
                    </a>
                </div>
                
                <div class="event-summary">
                    <div class="event-image-placeholder" id="sidebarEventImage"></div>
                    <h2 id="sidebarEventTitle">Event Title</h2>
                    <div class="event-datetime">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                            <line x1="16" x2="16" y1="2" y2="6"/>
                            <line x1="8" x2="8" y1="2" y2="6"/>
                            <line x1="3" x2="21" y1="10" y2="10"/>
                        </svg>
                        <span id="sidebarEventDateTime">Mon, Sep 1, 2025, 10:00 AM</span>
                    </div>
                    
                    <select class="status-select" id="eventStatus">
                        <option value="draft">Draft</option>
                        <option value="published">Published</option>
                    </select>
                    
                    <a href="#" class="preview-link" onclick="previewEvent()">Preview ‚Üó</a>
                </div>

                <div class="steps-section">
                    <h3>Steps</h3>
                    <div class="step-item completed" onclick="goToBuilder()">
                        <div class="step-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M9 12l2 2 4-4"/>
                                <circle cx="12" cy="12" r="10"/>
                            </svg>
                        </div>
                        <div class="step-content">
                            <h4>Build event page</h4>
                            <p>Add all of your event details and let attendees know what to expect</p>
                        </div>
                    </div>
                    
                    <div class="step-item active" id="ticketsStep">
                        <div class="step-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <circle cx="12" cy="12" r="10"/>
                            </svg>
                        </div>
                        <div class="step-content">
                            <h4>Add tickets</h4>
                            <p>Use our suggestions to help sell more tickets or manually create your own</p>
                        </div>
                    </div>
                    
                    <div class="step-item" id="publishStep" onclick="goToPublish()">
                        <div class="step-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <circle cx="12" cy="12" r="10"/>
                            </svg>
                        </div>
                        <div class="step-content">
                            <h4>Publish</h4>
                            <p>Review your event page and settings, then publish your event</p>
                        </div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Header -->
            <header class="header">
                <div class="header-content">
                    <div class="header-right">
                        <button class="preview-btn" onclick="previewEvent()">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                                <circle cx="12" cy="12" r="3"/>
                            </svg>
                            Preview Your Event
                        </button>
                        <button class="publish-btn" onclick="goToPublish()">Publish</button>
                        <div class="user-menu">
                            <div class="user-avatar" id="userAvatar">U</div>
                            <span class="user-name" id="userName">Loading...</span>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M7 10l5 5 5-5z"/>
                            </svg>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Content Area -->
            <div class="content-area">
                <div class="content-header">
                    <h1>Add tickets</h1>
                    <p>Create tickets for your event. You can add multiple ticket types with different prices and availability.</p>
                </div>

                <div class="tickets-content">
                    <!-- Ticket Type Selection -->
                    <div class="ticket-type-section">
                        <h3>Choose ticket type</h3>
                        <div class="ticket-type-buttons">
                            <button class="ticket-type-btn active" data-type="paid" onclick="selectTicketType('paid')">
                                <div class="ticket-type-icon">üí≥</div>
                                <div class="ticket-type-info">
                                    <h4>Paid</h4>
                                    <p>Charge attendees for tickets</p>
                                </div>
                            </button>
                            <button class="ticket-type-btn" data-type="free" onclick="selectTicketType('free')">
                                <div class="ticket-type-icon">üé´</div>
                                <div class="ticket-type-info">
                                    <h4>Free</h4>
                                    <p>Let attendees register for free</p>
                                </div>
                            </button>
                            <button class="ticket-type-btn" data-type="donation" onclick="selectTicketType('donation')">
                                <div class="ticket-type-icon">‚ù§Ô∏è</div>
                                <div class="ticket-type-info">
                                    <h4>Donation</h4>
                                    <p>Accept donations from attendees</p>
                                </div>
                            </button>
                        </div>
                    </div>

                    <!-- Existing Tickets List -->
                    <div class="existing-tickets" id="existingTickets">
                        <h3>Your tickets</h3>
                        <div class="tickets-list" id="ticketsList">
                            <!-- Tickets will be populated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Save Button -->
            <div class="save-section">
                <button class="save-btn" onclick="saveAndContinue()">Save and continue</button>
            </div>
        </main>

        <!-- Right Sidebar - Ticket Form -->
        <aside class="right-sidebar" id="rightSidebar">
            <div class="sidebar-content">
                <div class="form-header">
                    <h3 id="formTitle">Add paid ticket</h3>
                    <button class="close-btn" onclick="closeTicketForm()">√ó</button>
                </div>

                <form class="ticket-form" id="ticketForm">
                    <!-- Ticket Name -->
                    <div class="form-group">
                        <label for="ticketName">Ticket name *</label>
                        <input type="text" id="ticketName" placeholder="e.g. General Admission" required>
                    </div>

                    <!-- Ticket Price (for paid tickets) -->
                    <div class="form-group" id="priceGroup">
                        <label for="ticketPrice">Price *</label>
                        <div class="price-input">
                            <span class="currency">$</span>
                            <input type="number" id="ticketPrice" placeholder="0.00" step="0.01" min="0">
                        </div>
                    </div>

                    <!-- Donation Amount (for donation tickets) -->
                    <div class="form-group" id="donationGroup" style="display: none;">
                        <label for="suggestedDonation">Suggested donation amount</label>
                        <div class="price-input">
                            <span class="currency">$</span>
                            <input type="number" id="suggestedDonation" placeholder="0.00" step="0.01" min="0">
                        </div>
                    </div>

                    <!-- Quantity -->
                    <div class="form-group">
                        <label for="ticketQuantity">Quantity available</label>
                        <input type="number" id="ticketQuantity" placeholder="100" min="1">
                        <small>Leave blank for unlimited</small>
                    </div>

                    <!-- Description -->
                    <div class="form-group">
                        <label for="ticketDescription">Description</label>
                        <textarea id="ticketDescription" placeholder="Describe what's included with this ticket"></textarea>
                    </div>

                    <!-- Sale Period -->
                    <div class="form-group">
                        <label>Sale period</label>
                        <div class="date-inputs">
                            <div class="date-input-group">
                                <label for="saleStart">Start</label>
                                <input type="datetime-local" id="saleStart">
                            </div>
                            <div class="date-input-group">
                                <label for="saleEnd">End</label>
                                <input type="datetime-local" id="saleEnd">
                            </div>
                        </div>
                    </div>

                    <!-- Inventory Tier Selection -->
                    <div class="form-group">
                        <label for="inventoryTier">Inventory Tier (Optional)</label>
                        <select id="inventoryTier">
                            <option value="">No tier (General)</option>
                        </select>
                        <small>Assign this ticket class to a specific inventory tier</small>
                    </div>

                    <!-- Advanced Settings -->
                    <div class="advanced-settings">
                        <button type="button" class="advanced-toggle" onclick="toggleAdvanced()">
                            Advanced settings
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M7 10l5 5 5-5z"/>
                            </svg>
                        </button>
                        <div class="advanced-content" id="advancedContent" style="display: none;">
                            <!-- Quantity Restrictions -->
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="requireApproval">
                                    Require approval before purchase
                                </label>
                            </div>
                            <div class="form-group">
                                <label for="minQuantity">Minimum quantity per order</label>
                                <input type="number" id="minQuantity" value="1" min="1">
                            </div>
                            <div class="form-group">
                                <label for="maxQuantity">Maximum quantity per order</label>
                                <input type="number" id="maxQuantity" placeholder="10" min="1">
                            </div>

                            <!-- Visibility Settings -->
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="hiddenTicket">
                                    Hide this ticket class from public view
                                </label>
                            </div>

                            <!-- Fee Settings -->
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="includeFee">
                                    Include fees in displayed price
                                </label>
                                <small>When checked, the displayed price includes all fees</small>
                            </div>

                            <!-- Sales Channels -->
                            <div class="form-group">
                                <label>Sales Channels</label>
                                <div class="checkbox-group">
                                    <label><input type="checkbox" id="channelOnline" checked> Online</label>
                                    <label><input type="checkbox" id="channelAtd"> At the door</label>
                                    <label><input type="checkbox" id="channelFacebook"> Facebook</label>
                                </div>
                            </div>

                            <!-- Delivery Methods -->
                            <div class="form-group">
                                <label>Delivery Methods</label>
                                <div class="checkbox-group">
                                    <label><input type="checkbox" id="deliveryElectronic" checked> Electronic</label>
                                    <label><input type="checkbox" id="deliveryPhysical"> Physical mail</label>
                                    <label><input type="checkbox" id="deliveryWillCall"> Will call</label>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Form Actions -->
                    <div class="form-actions">
                        <button type="button" class="cancel-btn" onclick="closeTicketForm()">Cancel</button>
                        <button type="submit" class="save-ticket-btn">Save ticket</button>
                    </div>
                </form>
            </div>
        </aside>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            API_BASE_URL: (() => {
                // Check if running locally
                if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    return 'http://localhost:3000';
                }

                // Check for development netlify URL or specific backend URL
                if (window.location.hostname.includes('netlify.app')) {
                    return 'https://crowd-backend-zxxp.onrender.com';
                }

                // Default production backend
                return 'https://crowd-backend-zxxp.onrender.com';
            })(),
            RETRY_ATTEMPTS: 3,
            RETRY_DELAY: 2000, // Increased delay for better reliability
            TOKEN_KEY: 'authToken'
        };

        let currentEventData = {};
        let currentTicketType = 'paid';
        let editingTicketId = null;
        let eventTickets = [];
        let inventoryTiers = [];
        let ticketGroups = [];

        // Utility functions
        function sanitizeInput(input) {
            if (typeof input !== 'string') return input;
            return input.trim().replace(/[<>\"'&]/g, function(match) {
                const htmlEscapes = {
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;',
                    '&': '&amp;'
                };
                return htmlEscapes[match];
            });
        }

        function showErrorMessage(message, isTemporary = true) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-notification';
            errorDiv.textContent = message;
            errorDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #ef4444;
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                z-index: 1000;
                max-width: 400px;
                animation: slideIn 0.3s ease;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            `;

            document.body.appendChild(errorDiv);

            if (isTemporary) {
                setTimeout(() => {
                    if (errorDiv.parentNode) {
                        errorDiv.remove();
                    }
                }, 5000);
            }

            return errorDiv;
        }

        async function makeApiRequest(url, options = {}, retryCount = 0) {
            try {
                console.log(`Making API request to: ${url}`);

                const response = await fetch(url, {
                    ...options,
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    }
                });

                console.log(`Response status: ${response.status}`);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error Response: ${errorText}`);

                    // Handle 401 Unauthorized - try token refresh
                    if (response.status === 401 && retryCount === 0) {
                        console.log('Token expired, attempting refresh...');
                        const refreshed = await refreshAuthToken();
                        if (refreshed) {
                            console.log('Token refreshed, retrying request...');
                            // Update the Authorization header with new token
                            if (options.headers && options.headers.Authorization) {
                                options.headers.Authorization = `Bearer ${getAuthToken()}`;
                            }
                            return makeApiRequest(url, options, retryCount + 1);
                        } else {
                            console.log('Token refresh failed, redirecting to login...');
                            const currentPage = window.location.pathname.split('/').pop() + window.location.search;
                            window.location.href = `login.html?redirect=${encodeURIComponent(currentPage)}`;
                            return;
                        }
                    }

                    let errorMessage;
                    try {
                        const errorJson = JSON.parse(errorText);
                        errorMessage = errorJson.message || `HTTP ${response.status}: ${response.statusText}`;
                    } catch {
                        errorMessage = `HTTP ${response.status}: ${errorText || response.statusText}`;
                    }
                    throw new Error(errorMessage);
                }

                const responseData = await response.json();
                console.log('API Response:', responseData);
                return responseData;

            } catch (error) {
                console.error(`API Request failed (attempt ${retryCount + 1}):`, error);

                // Handle network errors and specific HTTP errors
                if (retryCount < CONFIG.RETRY_ATTEMPTS - 1 &&
                    (error.name === 'TypeError' ||
                     error.message.includes('network') ||
                     error.message.includes('Failed to fetch') ||
                     error.message.includes('500'))) {
                    console.log(`Retrying in ${CONFIG.RETRY_DELAY}ms...`);
                    await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY));
                    return makeApiRequest(url, options, retryCount + 1);
                }

                throw error;
            }
        }

        document.addEventListener('DOMContentLoaded', async function() {
            // Pure database authentication check
            const isAuthenticated = await checkAuthenticationStatus();
            if (!isAuthenticated) {
                // Redirect to login with the current page URL to return after login
                const currentPage = window.location.pathname.split('/').pop() + window.location.search;
                window.location.href = `login.html?redirect=${encodeURIComponent(currentPage)}`;
                return;
            }

            await loadUserData();
            await loadEventData();
            loadTickets();
            initializeForm();
            showTicketForm(); // Show form by default
        });

        async function loadUserData() {
            try {
                const data = await makeApiRequest(`${CONFIG.API_BASE_URL}/api/auth/profile`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${getAuthToken()}`
                    }
                });

                if (data.success && data.user) {
                    const user = data.user;
                    const firstName = sanitizeInput(user.firstName || '');
                    const lastName = sanitizeInput(user.lastName || '');
                    const initials = (firstName.charAt(0) + lastName.charAt(0)).toUpperCase() || 'U';
                    document.getElementById('userAvatar').textContent = initials;
                    document.getElementById('userName').textContent = `${firstName} ${lastName}`.trim() || 'User';
                }
            } catch (error) {
                console.error('Failed to load user data:', error);
                showErrorMessage('Failed to load user profile. Using default user info.');
                document.getElementById('userAvatar').textContent = 'U';
                document.getElementById('userName').textContent = 'User';
            }
        }

        async function loadEventData() {
            try {
                // Get event ID from URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const eventId = sanitizeInput(urlParams.get('id'));

                if (!eventId) {
                    showErrorMessage('No event ID provided. Redirecting to event builder.');
                    setTimeout(() => window.location.href = 'event-builder.html', 2000);
                    return;
                }

                console.log('Fetching event data for ID:', eventId);

                try {
                    // First, try to fetch basic event data
                    const eventData = await makeApiRequest(`${CONFIG.API_BASE_URL}/api/events/${eventId}`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${getAuthToken()}`
                        }
                    });

                    console.log('Event data response:', eventData);

                    if (eventData.success && eventData.event) {
                        currentEventData = eventData.event;

                        // Try to fetch advanced ticket classes data
                        try {
                            const ticketClassesData = await makeApiRequest(`${CONFIG.API_BASE_URL}/api/events/${eventId}/ticket-classes`, {
                                method: 'GET',
                                headers: {
                                    'Authorization': `Bearer ${getAuthToken()}`
                                }
                            });

                            console.log('Ticket classes API response:', ticketClassesData);

                            if (ticketClassesData.success) {
                                // Store advanced ticket data
                                currentEventData.ticketClasses = ticketClassesData.ticketClasses || [];
                                currentEventData.inventoryTiers = ticketClassesData.inventoryTiers || [];
                                currentEventData.ticketGroups = ticketClassesData.ticketGroups || [];
                                currentEventData.inventoryInfo = ticketClassesData.inventoryInfo || {};
                            } else {
                                // Fallback to basic ticket data
                                await loadEventDataFallback(eventId);
                                return;
                            }
                        } catch (ticketError) {
                            console.log('Advanced ticket classes not available, using fallback');
                            await loadEventDataFallback(eventId);
                            return;
                        }

                        populateEventInfo();
                        loadInventoryTiers();
                        loadTicketGroups();
                    } else {
                        throw new Error(eventData.message || 'Event not found');
                    }
                } catch (error) {
                    console.error('Error loading event data:', error);

                    // Check if it's a 404 error (event not found)
                    if (error.message.includes('404') || error.message.includes('Event not found')) {
                        showErrorMessage('Event not found. Creating a new event instead.');
                        // Create a default event structure for new events
                        await createDefaultEventStructure(eventId);
                    } else {
                        throw error;
                    }
                }
            } catch (error) {
                console.error('Failed to load event data:', error);
                showErrorMessage(`Failed to load event data: ${error.message}. Please check your connection and try again.`);

                // Offer user option to continue with a default event
                setTimeout(() => {
                    if (confirm('Would you like to create a new event instead?')) {
                        window.location.href = 'event-builder.html';
                    }
                }, 3000);
            }
        }

        // Fallback function for when ticket-classes endpoint doesn't exist
        async function loadEventDataFallback(eventId) {
            console.log('Using fallback event loading method');

            const data = await makeApiRequest(`${CONFIG.API_BASE_URL}/api/events/${eventId}`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${getAuthToken()}`
                }
            });

            if (data.success) {
                currentEventData = data.event;
                // Initialize empty advanced features for backward compatibility
                currentEventData.ticketClasses = currentEventData.pricing?.tickets || [];
                currentEventData.inventoryTiers = [];
                currentEventData.ticketGroups = [];
                currentEventData.inventoryInfo = { hasAdmissionTiers: false };

                populateEventInfo();
                loadInventoryTiers();
                loadTicketGroups();
            } else {
                throw new Error('Event API returned error: ' + data.message);
            }
        }

        // Create default event structure when event is not found
        async function createDefaultEventStructure(eventId) {
            console.log('Creating default event structure for new event');

            // Create a minimal event structure for ticket management
            currentEventData = {
                _id: eventId,
                title: 'New Event',
                description: 'Event description',
                status: 'draft',
                dateTime: {
                    start: new Date(),
                    end: new Date(Date.now() + 2 * 60 * 60 * 1000) // 2 hours later
                },
                location: {
                    type: 'venue',
                    venue: {
                        name: 'TBD',
                        address: {
                            city: 'TBD',
                            state: 'TBD',
                            country: 'USA'
                        }
                    }
                },
                pricing: {
                    type: 'paid',
                    amount: 0
                },
                ticketClasses: [],
                inventoryTiers: [],
                ticketGroups: [],
                inventoryInfo: { hasAdmissionTiers: false }
            };

            populateEventInfo();
            loadInventoryTiers();
            loadTicketGroups();

            showErrorMessage('Event not found. You can still add tickets, which will be saved when you create the event.', false);
        }

        // Pure database authentication check
        async function checkAuthenticationStatus() {
            try {
                const token = getAuthToken();
                if (!token) {
                    console.log('No auth token found');
                    return false;
                }

                const data = await makeApiRequest(`${CONFIG.API_BASE_URL}/api/auth/verify`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                console.log('Auth verification result:', data);
                return data.success;
            } catch (error) {
                console.error('Authentication check failed:', error);

                // Handle network errors more gracefully
                if (error.message.includes('Failed to fetch') || error.message.includes('network')) {
                    console.log('Network error during auth check, allowing offline mode');
                    showErrorMessage('Unable to verify authentication due to network issues. Working in offline mode.', true);
                    return true; // Allow working offline
                }

                showErrorMessage('Authentication verification failed. Please login again.');
                return false;
            }
        }

        function getAuthToken() {
            // Get from URL parameters first (for direct links)
            const urlParams = new URLSearchParams(window.location.search);
            let token = urlParams.get('token');

            // Use standardized token management
            if (!token) {
                token = localStorage.getItem(CONFIG.TOKEN_KEY);
            }

            // Store token consistently if found in URL
            if (token && !localStorage.getItem(CONFIG.TOKEN_KEY)) {
                localStorage.setItem(CONFIG.TOKEN_KEY, token);
            }

            console.log('Auth token found:', token ? 'Yes (length: ' + token.length + ')' : 'No');
            return token || '';
        }

        async function refreshAuthToken() {
            try {
                console.log('Attempting to refresh auth token...');
                const currentToken = getAuthToken();

                if (!currentToken) {
                    console.log('No current token to refresh');
                    return false;
                }

                const response = await fetch(`${CONFIG.API_BASE_URL}/api/auth/refresh`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.token) {
                        localStorage.setItem(CONFIG.TOKEN_KEY, data.token);
                        console.log('Token refreshed successfully');
                        return true;
                    }
                }

                console.log('Token refresh failed with status:', response.status);
                return false;
            } catch (error) {
                console.error('Error refreshing token:', error);
                return false;
            }
        }

        function populateEventInfo() {
            document.getElementById('sidebarEventTitle').textContent = sanitizeInput(currentEventData.title) || 'Event Title';
            document.getElementById('eventStatus').value = currentEventData.status || 'draft';

            if (currentEventData.image || currentEventData.imageUrl) {
                const imageUrl = currentEventData.image || currentEventData.imageUrl;
                document.getElementById('sidebarEventImage').style.backgroundImage = `url(${imageUrl})`;
                document.getElementById('sidebarEventImage').style.backgroundSize = 'cover';
            }

            // Update date time display - handle various date formats
            let dateValue = currentEventData.date || currentEventData.startDate || currentEventData.dateTime?.start;
            let timeValue = currentEventData.startTime || currentEventData.time;

            if (dateValue) {
                const date = new Date(dateValue);
                let startTime = 'Time not set';

                // Try to get time from various sources
                if (timeValue) {
                    startTime = formatTime(timeValue);
                } else if (dateValue.includes('T')) {
                    // ISO format includes time
                    startTime = formatTime(dateValue);
                } else {
                    startTime = 'Time not set';
                }

                const sidebarDisplay = date.toLocaleDateString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric'
                }) + `, ${startTime}`;
                document.getElementById('sidebarEventDateTime').textContent = sidebarDisplay;
            } else {
                document.getElementById('sidebarEventDateTime').textContent = 'Date not set';
            }
        }

        function formatTime(timeStr) {
            if (!timeStr) {
                return 'Time not set';
            }

            // Handle various time formats
            let timePart = timeStr;
            if (timeStr.includes('T')) {
                // ISO format like "2024-01-01T10:00:00"
                timePart = timeStr.split('T')[1].split('.')[0]; // Get time part
            }

            const [hours, minutes] = timePart.split(':');
            const hour = parseInt(hours);
            const ampm = hour >= 12 ? 'PM' : 'AM';
            const displayHour = hour % 12 || 12;
            return `${displayHour}${minutes !== '00' ? ':' + minutes : ''}${ampm}`;
        }

        function loadTickets() {
            try {
                // Get advanced ticket classes from the event data
                eventTickets = currentEventData.ticketClasses || [];
                renderTicketsList();
            } catch (error) {
                console.error('Failed to load tickets:', error);
                eventTickets = [];
                renderTicketsList();
            }
        }

        function loadInventoryTiers() {
            try {
                inventoryTiers = currentEventData.inventoryTiers || [];
                populateInventoryTierOptions();
            } catch (error) {
                console.error('Failed to load inventory tiers:', error);
                inventoryTiers = [];
            }
        }

        function loadTicketGroups() {
            try {
                ticketGroups = currentEventData.ticketGroups || [];
                renderTicketGroups();
            } catch (error) {
                console.error('Failed to load ticket groups:', error);
                ticketGroups = [];
            }
        }

        function renderTicketsList() {
            const ticketsList = document.getElementById('ticketsList');

            if (eventTickets.length === 0) {
                ticketsList.innerHTML = `
                    <div class="no-tickets">
                        <p>No ticket classes created yet. Use the form on the right to add your first ticket class.</p>
                    </div>
                `;
                return;
            }

            ticketsList.innerHTML = eventTickets.map(ticket => {
                let priceDisplay = '';
                if (ticket.type === 'free') {
                    priceDisplay = 'Free';
                } else if (ticket.type === 'donation') {
                    priceDisplay = ticket.suggestedDonation > 0 ?
                        `Donation (suggested: $${ticket.suggestedDonation})` : 'Donation';
                } else {
                    priceDisplay = `$${ticket.cost?.value || 0}`;
                }

                const quantityDisplay = ticket.quantity?.total ?
                    `${ticket.quantity.total} available (${ticket.quantity.sold || 0} sold)` :
                    'Unlimited';

                const tierName = ticket.inventoryTierId ?
                    getInventoryTierName(ticket.inventoryTierId) : '';

                return `
                    <div class="ticket-item" data-ticket-id="${ticket.id}">
                        <div class="ticket-info">
                            <h4>${ticket.name}</h4>
                            <p class="ticket-price">${priceDisplay}</p>
                            <p class="ticket-quantity">${quantityDisplay}</p>
                            ${tierName ? `<p class="ticket-tier">Tier: ${tierName}</p>` : ''}
                            <p class="ticket-type-badge">${ticket.type.toUpperCase()}</p>
                            ${ticket.visibility?.hidden ? '<p class="ticket-hidden">Hidden</p>' : ''}
                        </div>
                        <div class="ticket-actions">
                            <button class="edit-btn" onclick="editTicket('${ticket.id}')">Edit</button>
                            <button class="delete-btn" onclick="deleteTicket('${ticket.id}')">Delete</button>
                            <button class="remaining-btn" onclick="showRemainingTickets('${ticket.id}')">Remaining</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getInventoryTierName(tierId) {
            const tier = inventoryTiers.find(t => t.id === tierId);
            return tier ? tier.name : '';
        }

        function selectTicketType(type) {
            currentTicketType = type;
            
            // Update button states
            document.querySelectorAll('.ticket-type-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-type="${type}"]`).classList.add('active');
            
            // Update form
            updateFormForTicketType(type);
            showTicketForm();
        }

        function updateFormForTicketType(type) {
            const priceGroup = document.getElementById('priceGroup');
            const donationGroup = document.getElementById('donationGroup');
            const formTitle = document.getElementById('formTitle');
            
            // Reset form
            document.getElementById('ticketForm').reset();
            editingTicketId = null;
            
            switch(type) {
                case 'paid':
                    formTitle.textContent = 'Add paid ticket';
                    priceGroup.style.display = 'block';
                    donationGroup.style.display = 'none';
                    document.getElementById('ticketPrice').required = true;
                    break;
                case 'free':
                    formTitle.textContent = 'Add free ticket';
                    priceGroup.style.display = 'none';
                    donationGroup.style.display = 'none';
                    break;
                case 'donation':
                    formTitle.textContent = 'Add donation ticket';
                    priceGroup.style.display = 'none';
                    donationGroup.style.display = 'block';
                    break;
            }
        }

        function showTicketForm() {
            document.getElementById('rightSidebar').classList.add('active');
        }

        function closeTicketForm() {
            document.getElementById('rightSidebar').classList.remove('active');
            document.getElementById('ticketForm').reset();
            editingTicketId = null;
        }

        function initializeForm() {
            document.getElementById('ticketForm').addEventListener('submit', function(e) {
                e.preventDefault();
                saveTicket();
            });
        }

        async function saveTicket() {
            try {
                // Validate required fields
                const ticketName = sanitizeInput(document.getElementById('ticketName').value);
                if (!ticketName) {
                    showErrorMessage('Please enter a ticket name.');
                    return;
                }

                if (currentTicketType === 'paid') {
                    const price = parseFloat(document.getElementById('ticketPrice').value);
                    if (isNaN(price) || price < 0) {
                        showErrorMessage('Please enter a valid price.');
                        return;
                    }
                }

                // Prepare advanced ticket class data with sanitized inputs
                const ticketClassData = {
                    name: ticketName,
                    type: currentTicketType,
                    cost: {
                        value: currentTicketType === 'paid' ? parseFloat(document.getElementById('ticketPrice').value) : 0,
                        currency: 'USD',
                        display: currentTicketType === 'paid' ? `USD,${parseFloat(document.getElementById('ticketPrice').value)}` : null
                    },
                    suggestedDonation: currentTicketType === 'donation' ? parseFloat(document.getElementById('suggestedDonation').value) || 0 : 0,
                    quantity: {
                        total: document.getElementById('ticketQuantity').value ? parseInt(document.getElementById('ticketQuantity').value) : null,
                        sold: 0,
                        reserved: 0
                    },
                    restrictions: {
                        minimumQuantity: parseInt(document.getElementById('minQuantity').value) || 1,
                        maximumQuantity: document.getElementById('maxQuantity').value ? parseInt(document.getElementById('maxQuantity').value) : null,
                        requiresApproval: document.getElementById('requireApproval').checked
                    },
                    sales: {
                        start: document.getElementById('saleStart').value ? new Date(document.getElementById('saleStart').value).toISOString() : null,
                        end: document.getElementById('saleEnd').value ? new Date(document.getElementById('saleEnd').value).toISOString() : null,
                        hideSaleDates: false
                    },
                    visibility: {
                        hidden: document.getElementById('hiddenTicket') ? document.getElementById('hiddenTicket').checked : false,
                        autoHide: false,
                        autoHideBefore: null,
                        autoHideAfter: null
                    },
                    salesChannels: ['online'],
                    deliveryMethods: ['electronic'],
                    fees: {
                        includeFee: document.getElementById('includeFee') ? document.getElementById('includeFee').checked : false,
                        absorptionType: 'pass_fee'
                    },
                    description: sanitizeInput(document.getElementById('ticketDescription').value),
                    inventoryTierId: document.getElementById('inventoryTier') ? document.getElementById('inventoryTier').value || null : null,
                    order: eventTickets.length
                };

                // Get current event ID from URL
                const urlParams = new URLSearchParams(window.location.search);
                const eventId = sanitizeInput(urlParams.get('id'));

                let data;
                try {
                    if (editingTicketId) {
                        // Update existing ticket class
                        data = await makeApiRequest(`${CONFIG.API_BASE_URL}/api/events/${eventId}/ticket-classes/${editingTicketId}`, {
                            method: 'PUT',
                            headers: {
                                'Authorization': `Bearer ${getAuthToken()}`
                            },
                            body: JSON.stringify(ticketClassData)
                        });
                    } else {
                        // Create new ticket class
                        data = await makeApiRequest(`${CONFIG.API_BASE_URL}/api/events/${eventId}/ticket-classes`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${getAuthToken()}`
                            },
                            body: JSON.stringify(ticketClassData)
                        });
                    }

                    if (data.success) {
                        // Reload ticket classes data
                        await loadEventData();

                        showNotification(editingTicketId ? 'Ticket class updated successfully!' : 'Ticket class created successfully!');
                        renderTicketsList();
                        closeTicketForm();
                    } else {
                        throw new Error(data.message || 'Failed to save ticket class');
                    }
                } catch (apiError) {
                    // If API fails, save locally and show informative message
                    console.log('API save failed, saving locally:', apiError);

                    // Add ticket class to local event data
                    if (editingTicketId) {
                        const index = eventTickets.findIndex(t => t.id === editingTicketId);
                        if (index !== -1) {
                            eventTickets[index] = { ...ticketClassData, id: editingTicketId };
                        }
                    } else {
                        ticketClassData.id = generateTicketId();
                        eventTickets.push(ticketClassData);
                    }

                    // Update current event data
                    currentEventData.ticketClasses = eventTickets;

                    showNotification(`Ticket class saved locally! ${editingTicketId ? 'Updated' : 'Created'} successfully. Will sync when connection is restored.`);
                    renderTicketsList();
                    closeTicketForm();
                }

            } catch (error) {
                console.error('Failed to save ticket class:', error);
                showErrorMessage('Failed to save ticket class: ' + error.message);
            }
        }

        function editTicket(ticketId) {
            const ticket = eventTickets.find(t => t.id === ticketId);
            if (!ticket) return;

            editingTicketId = ticketId;
            currentTicketType = ticket.type;
            
            // Update ticket type selection
            selectTicketType(ticket.type);
            
            // Populate form
            document.getElementById('ticketName').value = ticket.name;
            document.getElementById('ticketPrice').value = ticket.price;
            document.getElementById('suggestedDonation').value = ticket.suggestedDonation;
            document.getElementById('ticketQuantity').value = ticket.quantity || '';
            document.getElementById('ticketDescription').value = ticket.description;
            document.getElementById('saleStart').value = ticket.saleStart;
            document.getElementById('saleEnd').value = ticket.saleEnd;
            document.getElementById('requireApproval').checked = ticket.requireApproval;
            document.getElementById('minQuantity').value = ticket.minQuantity;
            document.getElementById('maxQuantity').value = ticket.maxQuantity || '';
            
            // Update form title
            document.getElementById('formTitle').textContent = `Edit ${ticket.type} ticket`;
            
            showTicketForm();
        }

        async function deleteTicket(ticketId) {
            if (confirm('Are you sure you want to delete this ticket class?')) {
                try {
                    // Get current event ID from URL
                    const urlParams = new URLSearchParams(window.location.search);
                    const eventId = sanitizeInput(urlParams.get('id'));

                    try {
                        // Delete ticket class using new API
                        const data = await makeApiRequest(`${CONFIG.API_BASE_URL}/api/events/${eventId}/ticket-classes/${ticketId}`, {
                            method: 'DELETE',
                            headers: {
                                'Authorization': `Bearer ${getAuthToken()}`
                            }
                        });

                        if (data.success) {
                            // Reload ticket classes data
                            await loadEventData();

                            renderTicketsList();
                            showNotification('Ticket class deleted successfully!');
                        } else {
                            throw new Error(data.message || 'Failed to delete ticket class');
                        }
                    } catch (apiError) {
                        // If API fails, delete locally
                        console.log('API delete failed, deleting locally:', apiError);

                        // Remove from local event data
                        eventTickets = eventTickets.filter(t => t.id !== ticketId);
                        currentEventData.ticketClasses = eventTickets;

                        renderTicketsList();
                        showNotification('Ticket class deleted locally! Will sync when connection is restored.');
                    }

                } catch (error) {
                    console.error('Failed to delete ticket class:', error);
                    showErrorMessage('Failed to delete ticket class: ' + error.message);
                }
            }
        }

        function generateTicketId() {
            return 'ticket_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Show remaining tickets for a ticket class
        async function showRemainingTickets(ticketClassId) {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const eventId = sanitizeInput(urlParams.get('id'));

                const data = await makeApiRequest(`${CONFIG.API_BASE_URL}/api/events/${eventId}/ticket-classes/${ticketClassId}/remaining`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${getAuthToken()}`
                    }
                });

                if (data.success) {
                    const message = data.unlimited ?
                        'This ticket class has unlimited quantity.' :
                        `Remaining tickets: ${data.remaining}\nTotal: ${data.quantityTotal}\nSold: ${data.quantitySold}\nReserved: ${data.quantityReserved}`;

                    alert(message);
                } else {
                    throw new Error(data.message || 'Failed to get remaining tickets');
                }

            } catch (error) {
                console.error('Failed to get remaining tickets:', error);
                showErrorMessage('Failed to get remaining tickets: ' + error.message);
            }
        }

        // Populate inventory tier options
        function populateInventoryTierOptions() {
            const tierSelect = document.getElementById('inventoryTier');
            if (!tierSelect) return;

            tierSelect.innerHTML = '<option value="">No tier (General)</option>';

            inventoryTiers.forEach(tier => {
                const option = document.createElement('option');
                option.value = tier.id;
                option.textContent = `${tier.name} (${tier.quantityTotal || 'Unlimited'})`;
                tierSelect.appendChild(option);
            });
        }

        // Render ticket groups (for future enhancement)
        function renderTicketGroups() {
            // This would be implemented for grouping functionality
            console.log('Ticket groups loaded:', ticketGroups.length);
        }

        function toggleAdvanced() {
            const content = document.getElementById('advancedContent');
            const toggle = document.querySelector('.advanced-toggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.classList.add('expanded');
            } else {
                content.style.display = 'none';
                toggle.classList.remove('expanded');
            }
        }

        function showNotification(message) {
            // Simple notification - you can enhance this
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #10b981;
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                z-index: 1000;
                animation: slideIn 0.3s ease;
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        async function saveAndContinue() {
            try {
                // Validate that at least one ticket exists
                if (!eventTickets || eventTickets.length === 0) {
                    showErrorMessage('Please create at least one ticket before continuing.');
                    return;
                }

                // Get current event ID from URL
                const urlParams = new URLSearchParams(window.location.search);
                const eventId = sanitizeInput(urlParams.get('id'));

                // Update event with tickets configured status
                const updateData = {
                    ticketsConfigured: true,
                    updatedAt: new Date().toISOString()
                };

                const data = await makeApiRequest(`${CONFIG.API_BASE_URL}/api/events/${eventId}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${getAuthToken()}`
                    },
                    body: JSON.stringify(updateData)
                });

                if (data.success) {
                    // Mark tickets step as completed
                    const ticketsStep = document.getElementById('ticketsStep');
                    if (ticketsStep) {
                        ticketsStep.classList.add('completed');
                        ticketsStep.classList.remove('active');
                        const stepIcon = ticketsStep.querySelector('.step-icon');
                        if (stepIcon) {
                            stepIcon.innerHTML = `
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M9 12l2 2 4-4"/>
                                    <circle cx="12" cy="12" r="10"/>
                                </svg>
                            `;
                        }
                    }

                    // Navigate to publish page with event ID
                    window.location.href = `publish-event.html?id=${eventId}`;
                } else {
                    throw new Error(data.message || 'Failed to save progress');
                }

            } catch (error) {
                console.error('Failed to save and continue:', error);
                showErrorMessage('Failed to save progress: ' + error.message);
            }
        }

        function previewEvent() {
            const urlParams = new URLSearchParams(window.location.search);
            const eventId = urlParams.get('id');
            if (eventId) {
                window.location.href = `event-preview.html?id=${eventId}`;
            } else {
                alert('Event ID not found');
            }
        }

        function goToPublish() {
            const urlParams = new URLSearchParams(window.location.search);
            const eventId = urlParams.get('id');
            if (eventId) {
                window.location.href = `publish-event.html?id=${eventId}`;
            } else {
                alert('Event ID not found');
            }
        }

        function goToBuilder() {
            const urlParams = new URLSearchParams(window.location.search);
            const eventId = urlParams.get('id');
            if (eventId) {
                window.location.href = `event-builder.html?id=${eventId}`;
            } else {
                window.location.href = 'event-builder.html';
            }
        }
    </script>
</body>
</html>
